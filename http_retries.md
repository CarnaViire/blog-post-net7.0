# HTTP Retry Logic Changes

.NET 6 [changes](https://github.com/dotnet/runtime/pull/48758) the HTTP request retry logic to be based on a fixed retry count limit.

Previously, .NET 5 disallowed request retries on connection failure when the failure occurred on a "new" connection (one that hadn't been used for previous requests). We did this mainly to ensure that the retry logic doesn't end up in an infinite loop. This was suboptimal and specifically problematic for [HTTP/2 connections](https://github.com/dotnet/runtime/issues/44669). On the other hand, .NET 5 was too lenient about allowing retries in many cases. That behavior wasn't fully compliant with the [RFC](https://datatracker.ietf.org/doc/html/rfc2616#section-8.1.4) and could be dangerous. For example, we were retrying on arbitrary exceptions, e.g. on IO timeouts, even though the user was explicitly setting this timeout and presumably wanted to fail (not retry) the request when the timeout was exceeded.

.NET 6 retry logic will work regardless of the request being the first one on a connection. It introduces the retry limit which is currently set to 5. In future, we might consider adjusting it or making it configurable, if desired.

To comply better with the RFC, requests are now only retriable when we believe that the server is attempting to gracefully tear down a connection -- that is, when we receive EOF before any other response data for HTTP/1.1, or receive GOAWAY for HTTP/2.

The downside to more conservative retry behavior of .NET 6 is that the failures previously masked by lenient retry policy will start to be visible to users. For example, if a server tears down idle connections in a non-graceful way (by sending TCP RST packet), the requests failed because of RST will not be automatically retried. This was briefly touched upon in the [AAD article about migration to .NET 6](https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-is-on-net-6-0/#learnings). The workaround would be to set [client's idle timeout](https://docs.microsoft.com/en-us/dotnet/api/system.net.http.socketshttphandler.pooledconnectionidletimeout?view=net-6.0) to 50-75% of server's idle timeout (if it's known). That way a request should never get caught in the race with the server closing the connection as idle -- `HttpClient` will scavenge it sooner. Another approach would be to implement a custom retry policy outside of  `HttpClient`. That would also allow to tweak the retry policy and heuristics, for example, if some generally non-idempotent requests could be retried depending on a specific server's logic and implementation.